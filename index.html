<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=640">

    <link rel="stylesheet" href="stylesheets/core.css" media="screen">
    <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">

    <script type="text/javascript" src="javascripts/modernizr.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/headsmart.min.js"></script>
    <script type="text/javascript">
      $(document).ready(function () {
        $('#main_content').headsmart()
      })
    </script>
    <title>Active-sqlalchemy by mardix</title>
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/mardix/active-sqlalchemy">View on GitHub</a>
    <div class="shell">

      <header>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <h1>Active-sqlalchemy</h1>
            <h2>Active-SQLAlchemy is a framework agnostic wrapper for SQLAlchemy that makes it really easy to use by implementing a simple active record like api, while it still uses the db.session underneath. Inspired by Flask-SQLAlchemy</h2>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
      </header>

      <section id="downloads">
        <span class="inner">
          <a href="https://github.com/mardix/active-sqlalchemy/zipball/master" class="zip"><em>download</em> .ZIP</a><a href="https://github.com/mardix/active-sqlalchemy/tarball/master" class="tgz"><em>download</em> .TGZ</a>
        </span>
      </section>


      <span class="banner-fix"></span>


      <section id="main_content">
        <h1>
<a name="active-sqlalchemy" class="anchor" href="#active-sqlalchemy"><span class="octicon octicon-link"></span></a>Active-SQLAlchemy</h1>

<p><strong>Version 0.2.*</strong></p>

<hr><p>Active-SQLAlchemy is a framework agnostic wrapper for SQLAlchemy that makes it really easy
to use by implementing a simple active record like api, while it still uses the db.session underneath.
Inspired by Flask-SQLAlchemy.</p>

<p>Works with Python 2.6, 2.7, 3.3, 3.4 and pypy.</p>

<hr><h2>
<a name="quick-overview" class="anchor" href="#quick-overview"><span class="octicon octicon-link"></span></a>Quick Overview:</h2>

<h4>
<a name="create-the-model" class="anchor" href="#create-the-model"><span class="octicon octicon-link"></span></a>Create the model</h4>

<pre><code>from active_sqlalchemy import SQLAlchemy

db = SQLAlchemy('pymysql+mysql://user:password@host:port/mydatabase')

class User(db.Model):
    name = db.Column(db.String(25))
    location = db.Column(db.String(50), default="USA")
    last_access = db.Column(db.Datetime)
</code></pre>

<h4>
<a name="create-new-record" class="anchor" href="#create-new-record"><span class="octicon octicon-link"></span></a>Create new record</h4>

<pre><code>user = User.create(name="Mardix", location="Moon")

# or

user = User(name="Mardix", location="Moon").save()
</code></pre>

<h4>
<a name="get-all-records" class="anchor" href="#get-all-records"><span class="octicon octicon-link"></span></a>Get all records</h4>

<pre><code>all = User.all()
</code></pre>

<h4>
<a name="get-a-record-by-id" class="anchor" href="#get-a-record-by-id"><span class="octicon octicon-link"></span></a>Get a record by id</h4>

<pre><code>user = User.get(1234)
</code></pre>

<h4>
<a name="update-record" class="anchor" href="#update-record"><span class="octicon octicon-link"></span></a>Update record</h4>

<pre><code>user = User.get(1234)
if user:
    user.update(location="Neptune") 
</code></pre>

<h4>
<a name="soft-delete-a-record" class="anchor" href="#soft-delete-a-record"><span class="octicon octicon-link"></span></a>Soft Delete a record</h4>

<pre><code>user = User.get(1234)
if user:
    user.delete() 
</code></pre>

<h4>
<a name="query-records" class="anchor" href="#query-records"><span class="octicon octicon-link"></span></a>Query Records</h4>

<pre><code>users = User.all(User.location.distinct())

for user in users:
    ...
</code></pre>

<h4>
<a name="query-with-filter" class="anchor" href="#query-with-filter"><span class="octicon octicon-link"></span></a>Query with filter</h4>

<pre><code>all = User.all().filter(User.location == "USA")

for user in users:
    ...
</code></pre>

<h2>
<a name="how-to-use" class="anchor" href="#how-to-use"><span class="octicon octicon-link"></span></a>How to use</h2>

<h4>
<a name="install" class="anchor" href="#install"><span class="octicon octicon-link"></span></a>Install</h4>

<pre><code>pip install active_sqlalchemy
</code></pre>

<p>PIP install directly from Github</p>

<pre><code>pip install https://github.com/mardix/active-sqlalchemy/archive/master.zip
</code></pre>

<h4>
<a name="create-a-connection" class="anchor" href="#create-a-connection"><span class="octicon octicon-link"></span></a>Create a connection</h4>

<p>The SQLAlchemy class is used to instantiate a SQLAlchemy connection to
a database.</p>

<pre><code>from active_sqlalchemy import SQLAlchemy

db = SQLAlchemy(_uri_to_database_)
</code></pre>

<p>The class also provides access to all the SQLAlchemy
functions from the <code>sqlalchemy</code> and <code>sqlalchemy.orm</code> modules.
So you can declare models like this:</p>

<hr><h3>
<a name="create-a-model" class="anchor" href="#create-a-model"><span class="octicon octicon-link"></span></a>Create a Model</h3>

<p>To start, create a model class and extends it with db.Model</p>

<pre><code># mymodel.py

from active_sqlachemy import SQLAlchemy

db = SQLAlchemy("pymysql://user:pass@host:port/dbname")

class MyModel(db.Model):
    name = db.Column(db.String(25))
    is_live = db.Column(db.Boolean, default=False)

# Put at the end of the model module to auto create all models
db.create_all()
</code></pre>

<ul>
<li><p>Upon creation of the table, db.Model will add the following columns: <code>id</code>, <code>created_at</code>, <code>upated_at</code>, <code>is_deleted</code>, <code>deleted_at</code></p></li>
<li><p>It does an automatic table naming (if no table name is already defined using the <code>__tablename__</code> property)
by using the class name. So, for example, a <code>User</code> model gets a table named <code>user</code>, <code>TodoList</code> becomes <code>todo_list</code>
The name will not be plurialized.</p></li>
</ul><hr><h2>
<a name="models-dbmodel" class="anchor" href="#models-dbmodel"><span class="octicon octicon-link"></span></a>Models: <em>db.Model</em>
</h2>

<p><strong>db.Model</strong> extends your model with helpers that turn your model into an active record like model. But underneath, it still uses the <code>db.session</code> </p>

<p><strong>db.Model</strong> also adds a few preset columns on the table: </p>

<p><code>id</code>: The primary key</p>

<p><code>created_at</code>: Datetime. It contains the creation date of the record</p>

<p><code>updated_at</code>: Datetime. It is updated whenever the record is updated.</p>

<p><code>deleted_at</code>: Datetime. Contains the datetime the record was soft-deleted. </p>

<p><code>is_deleted</code>: Boolean. A flag to set if record is soft-deleted or not</p>

<p><strong>-- About Soft Delete --</strong></p>

<p>By definition, soft-delete marks a record as deleted so it doesn't get queried, but it still exists in the database. To actually delete the record itself, a hard delete must apply. </p>

<p>By default, when a record is deleted, <strong>Active-SQLAlchemy</strong> actually sets <code>is_deleted</code> to True and excludes it from being queried, and <code>deleted_at</code> is also set. But this happens only when using the method <code>db.Model.delete()</code>.</p>

<p>When a record is soft-deleted, you can also undelete a record by doing: <code>db.Model.delete(False)</code></p>

<p>Now, to totally delete off the table, <code>db.Model.delete(hard_delete=True)</code>   </p>

<p><strong>-- Querying with <em>db.Model.all()</em> --</strong></p>

<p>Due to the fact that <strong>Active-SQLAlchemy</strong> has soft-delete, to query a model without the soft-deleted records, you must query your model by using the <code>all(*args, **kwargs)</code> which returns a db.session.query object for you to apply filter on etc.</p>

<p><strong>-- db.BaseModel --</strong></p>

<p>By default <code>db.Model</code> adds several preset columns on the table, if you don't want to have them in your model, you can use instead <code>db.BaseModel</code>, which still give you access to the methods to query your model.</p>

<hr><h3>
<a name="dbmodel-methods-description" class="anchor" href="#dbmodel-methods-description"><span class="octicon octicon-link"></span></a>db.Model Methods Description</h3>

<p><strong>all(*args, **kwargs)</strong></p>

<p>Returns a <code>db.session.query</code> object to filter or apply more conditions. </p>

<pre><code>all = User.all()
for user in all:
    print(user.login)
</code></pre>

<p>By default all() will show only all non-soft-delete records. To display both deleted and non deleted items, add the arg: <code>exclude_deleted=False</code></p>

<pre><code>all = User.all(exclude_deleted=False)
for user in all:
    print(user.login)
</code></pre>

<p>Use all to select columns etc</p>

<pre><code>all = User.all(User.name.distinct(), User.location)
for user in all:
    print(user.login)
</code></pre>

<p>Use all for complete filter</p>

<pre><code>all = User.all(User.name.distinct, User.location).order_by(User.updated_at.desc()).filter(User.location == "Charlotte")
</code></pre>

<p><strong>get(id)</strong></p>

<p>Get one record by id. By default it will query only a record that is not soft-deleted</p>

<pre><code>id = 1234
user = User.get(id)

print(user.id)
print(user.login)
</code></pre>

<p>To query a record that has been soft deleted, just set the argument <code>exclude_deleted=False</code></p>

<pre><code>id = 234
user = User.get(id, exclude_deleted=False)
</code></pre>

<p><strong>create(**kwargs)</strong></p>

<p>To create/insert new record. Same as <strong>init</strong>, but just a shortcut to it.</p>

<pre><code>record = User.create(login='abc', passw_hash='hash', profile_id=123)
print (record.login) # -&gt; abc
</code></pre>

<p>or you can use the <strong>init</strong> with save()</p>

<pre><code>record = User(login='abc', passw_hash='hash', profile_id=123).save()
print (record.login) # -&gt; abc
</code></pre>

<p>or </p>

<pre><code>record = User(login='abc', passw_hash='hash', profile_id=123)
record.save()
print (record.login) # -&gt; abc
</code></pre>

<p><strong>update(**kwargs)</strong></p>

<p>Update an existing record </p>

<pre><code>record = User.get(124)
record.update(login='new_login')
print (record.login) # -&gt; new_login
</code></pre>

<p><strong>delete()</strong></p>

<p>To soft delete a record. <code>is_deleted</code> will be set to True and <code>deleted_at</code> datetime will be set</p>

<pre><code>record = User.get(124)
record.delete()
print (record.is_deleted) # -&gt; True
</code></pre>

<p>To soft UNdelete a record. <code>is_deleted</code> will be set to False and <code>deleted_at</code> datetime will be None</p>

<pre><code>record = User.get(124)
record.delete(delete=False)
print (record.is_deleted) # -&gt; False
</code></pre>

<p>To HARD delete a record. The record will be deleted completely</p>

<pre><code>record = User.get(124)
record.delete(hard_delete=True)
</code></pre>

<p><strong>save()</strong></p>

<p>A shortcut to <code>session.add</code> + <code>session.commit()</code></p>

<pre><code>record = User.get(124)
record.login = "Another one"
record.save()
</code></pre>

<hr><h4>
<a name="method-chaining" class="anchor" href="#method-chaining"><span class="octicon octicon-link"></span></a>Method Chaining</h4>

<p>For convenience, some method chaining are available</p>

<pre><code>user = User(name="Mardix", location="Charlotte").save()

User.get(12345).update(location="Atlanta")

User.get(345).delete().delete(False).update(location="St. Louis")
</code></pre>

<hr><h4>
<a name="aggegated-selects" class="anchor" href="#aggegated-selects"><span class="octicon octicon-link"></span></a>Aggegated selects</h4>

<pre><code>class Product(db.Model):
    name = db.Column(db.String(250))
    price = db.Column(db.Numeric)

results = Product.all(db.func.sum(Unit.price).label('price'))
</code></pre>

<hr><h2>
<a name="with-web-application" class="anchor" href="#with-web-application"><span class="octicon octicon-link"></span></a>With Web Application</h2>

<p>In a web application you need to call <code>db.session.remove()</code> after each response, and <code>db.session.rollback()</code> if an error occurs. However, if you are using Flask or other framework that uses the <code>after_request</code> and <code>on_exception</code> decorators, these bindings it is done automatically.</p>

<p>For example using Flask, you can do:</p>

<pre><code>app = Flask(__name__)

db = SQLAlchemy('sqlite://', app=app)
</code></pre>

<p>or</p>

<pre><code>db = SQLAlchemy()

app = Flask(__name__)

db.init_app(app)
</code></pre>

<h3>
<a name="more-examples" class="anchor" href="#more-examples"><span class="octicon octicon-link"></span></a>More examples</h3>

<h4>
<a name="many-databases-one-web-app" class="anchor" href="#many-databases-one-web-app"><span class="octicon octicon-link"></span></a>Many databases, one web app</h4>

<pre><code>app = Flask(__name__)
db1 = SQLAlchemy(URI1, app)
db2 = SQLAlchemy(URI2, app)
</code></pre>

<h4>
<a name="many-web-apps-one-database" class="anchor" href="#many-web-apps-one-database"><span class="octicon octicon-link"></span></a>Many web apps, one database</h4>

<pre><code>db = SQLAlchemy(URI1)

app1 = Flask(__name__)
app2 = Flask(__name__)
db.init_app(app1)
db.init_app(app2)
</code></pre>

<hr><h2>
<a name="pagination" class="anchor" href="#pagination"><span class="octicon octicon-link"></span></a>Pagination</h2>

<p>All the results can be easily paginated</p>

<pre><code>users = User.paginate(page=2, per_page=20)
print(list(users))  # [User(21), User(22), User(23), ... , User(40)]
</code></pre>

<p>The paginator object it's an iterable that returns only the results for that page, so you use it in your templates in the same way than the original result:</p>

<pre><code>{% for item in paginated_items %}
    &lt;li&gt;{{ item.name }}&lt;/li&gt;
{% endfor %}
</code></pre>

<p>Rendering the pages</p>

<p>Below your results is common that you want it to render the list of pages.</p>

<p>The <code>paginator.pages</code> property is an iterator that returns the page numbers, but sometimes not all of them: if there are more than 11 pages, the result will be one of these, depending of what is the current page:</p>

<p>Skipped page numbers are represented as <code>None</code>.</p>

<p>How many items are displayed can be controlled calling <code>paginator.iter_pages</code> instead.</p>

<p>This is one way how you could render such a pagination in your templates:</p>

<pre><code>{% macro render_paginator(paginator, endpoint) %}
  &lt;p&gt;Showing {{ paginator.showing }} or {{ paginator.total }}&lt;/p&gt;

  &lt;ol class="paginator"&gt;
  {%- if paginator.has_prev %}
    &lt;li&gt;&lt;a href="{{ url_for(endpoint, page=paginator.prev_num) }}"
     rel="me prev"&gt;«&lt;/a&gt;&lt;/li&gt;
  {% else %}
    &lt;li class="disabled"&gt;&lt;span&gt;«&lt;/span&gt;&lt;/li&gt;
  {%- endif %}

  {%- for page in paginator.pages %}
    {% if page %}
      {% if page != paginator.page %}
        &lt;li&gt;&lt;a href="{{ url_for(endpoint, page=page) }}"
         rel="me"&gt;{{ page }}&lt;/a&gt;&lt;/li&gt;
      {% else %}
        &lt;li class="current"&gt;&lt;span&gt;{{ page }}&lt;/span&gt;&lt;/li&gt;
      {% endif %}
    {% else %}
      &lt;li&gt;&lt;span class=ellipsis&gt;…&lt;/span&gt;&lt;/li&gt;
    {% endif %}
  {%- endfor %}

  {%- if paginator.has_next %}
    &lt;li&gt;&lt;a href="{{ url_for(endpoint, page=paginator.next_num) }}"
     rel="me next"&gt;»&lt;/a&gt;&lt;/li&gt;
  {% else %}
    &lt;li class="disabled"&gt;&lt;span&gt;»&lt;/span&gt;&lt;/li&gt;
  {%- endif %}
  &lt;/ol&gt;
{% endmacro %}
</code></pre>

<hr><h4>
<a name="credits" class="anchor" href="#credits"><span class="octicon octicon-link"></span></a>Credits:</h4>

<p><a href="http://www.sqlalchemy.org/">SQLAlchemy</a></p>

<p><a href="https://pythonhosted.org/Flask-SQLAlchemy">Flask-SQLAlchemy</a></p>

<p><a href="https://github.com/lucuma/sqlalchemy-wrapper">SQLAlchemy-Wrapper</a></p>

<hr><p><img class="emoji" title=":copyright:" alt=":copyright:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/00a9.png" height="20" width="20" align="absmiddle"> 2014</p>

<p>:license: MIT, see LICENSE for more details.</p>
      </section>

      <footer>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <p>this project by <a href="https://github.com/mardix">mardix</a> can be found on <a href="https://github.com/mardix/active-sqlalchemy">GitHub</a></p>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
        <p>Generated with <a href="http://pages.github.com">GitHub Pages</a> using Merlot</p>
        <span class="octocat"></span>
      </footer>

    </div>

    
  </body>
</html>
