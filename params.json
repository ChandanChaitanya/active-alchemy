{"name":"Active-sqlalchemy","tagline":"Active-SQLAlchemy is a framework agnostic wrapper for SQLAlchemy that makes it really easy to use by implementing a simple active record like api, while it still uses the db.session underneath. Inspired by Flask-SQLAlchemy","body":"\r\n#Active-SQLAlchemy\r\n\r\n**Version 0.2.***\r\n\r\n---\r\n\r\nActive-SQLAlchemy is a framework agnostic wrapper for SQLAlchemy that makes it really easy\r\nto use by implementing a simple active record like api, while it still uses the db.session underneath.\r\nInspired by Flask-SQLAlchemy.\r\n\r\nWorks with Python 2.6, 2.7, 3.3, 3.4 and pypy.\r\n\r\n---\r\n\r\n##Quick Overview:\r\n\r\n####Create the model\r\n\r\n\r\n    from active_sqlalchemy import SQLAlchemy\r\n\r\n    db = SQLAlchemy('pymysql+mysql://user:password@host:port/mydatabase')\r\n\r\n\tclass User(db.Model):\r\n\t\tname = db.Column(db.String(25))\r\n\t\tlocation = db.Column(db.String(50), default=\"USA\")\r\n\t\tlast_access = db.Column(db.Datetime)\r\n\r\n\r\n####Create new record\r\n\r\n\r\n\tuser = User.create(name=\"Mardix\", location=\"Moon\")\r\n\t\r\n\t# or\r\n\t\r\n\tuser = User(name=\"Mardix\", location=\"Moon\").save()\r\n\t\r\n\t\r\n####Get all records\r\n\r\n    all = User.all()\r\n    \r\n    \r\n####Get a record by id\r\n\r\n    user = User.get(1234)\r\n\r\n\r\n####Update record\r\n\r\n\tuser = User.get(1234)\r\n\tif user:\r\n\t\tuser.update(location=\"Neptune\") \r\n\r\n\r\n####Soft Delete a record\r\n\r\n\tuser = User.get(1234)\r\n\tif user:\r\n\t\tuser.delete() \r\n\t\t\r\n####Query Records\r\n\r\n    users = User.all(User.location.distinct())\r\n\r\n    for user in users:\r\n        ...\r\n\r\n\r\n####Query with filter\r\n\r\n\r\n    all = User.all().filter(User.location == \"USA\")\r\n\r\n    for user in users:\r\n        ...\r\n\r\n\r\n\r\n##How to use\r\n\r\n\r\n#### Install\r\n\r\n\r\n    pip install active_sqlalchemy\r\n\r\n\r\nPIP install directly from Github\r\n\r\n\r\n\r\n    pip install https://github.com/mardix/active-sqlalchemy/archive/master.zip\r\n\r\n\r\n#### Create a connection \r\n\r\nThe SQLAlchemy class is used to instantiate a SQLAlchemy connection to\r\na database.\r\n\r\n\r\n    from active_sqlalchemy import SQLAlchemy\r\n\r\n    db = SQLAlchemy(_uri_to_database_)\r\n\r\n\r\nThe class also provides access to all the SQLAlchemy\r\nfunctions from the ``sqlalchemy`` and ``sqlalchemy.orm`` modules.\r\nSo you can declare models like this:\r\n\r\n---\r\n\r\n### Create a Model\r\n\r\nTo start, create a model class and extends it with db.Model\r\n\r\n\t# mymodel.py\r\n\t\r\n    from active_sqlachemy import SQLAlchemy\r\n\r\n    db = SQLAlchemy(\"pymysql://user:pass@host:port/dbname\")\r\n    \r\n    class MyModel(db.Model):\r\n    \tname = db.Column(db.String(25))\r\n    \tis_live = db.Column(db.Boolean, default=False)\r\n    \t\r\n    # Put at the end of the model module to auto create all models\r\n    db.create_all()\r\n\r\n\r\n- Upon creation of the table, db.Model will add the following columns: ``id``, ``created_at``, ``upated_at``, ``is_deleted``, ``deleted_at``\r\n\r\n- It does an automatic table naming (if no table name is already defined using the ``__tablename__`` property)\r\nby using the class name. So, for example, a ``User`` model gets a table named ``user``, ``TodoList`` becomes ``todo_list``\r\nThe name will not be plurialized.\r\n\r\n---\r\n\r\n## Models: *db.Model*\r\n\r\n**db.Model** extends your model with helpers that turn your model into an active record like model. But underneath, it still uses the ``db.session`` \r\n\r\n**db.Model** also adds a few preset columns on the table: \r\n\r\n``id``: The primary key\r\n\r\n``created_at``: Datetime. It contains the creation date of the record\r\n\r\n``updated_at``: Datetime. It is updated whenever the record is updated.\r\n\r\n``deleted_at``: Datetime. Contains the datetime the record was soft-deleted. \r\n\r\n``is_deleted``: Boolean. A flag to set if record is soft-deleted or not\r\n\r\n**-- About Soft Delete --**\r\n\r\nBy definition, soft-delete marks a record as deleted so it doesn't get queried, but it still exists in the database. To actually delete the record itself, a hard delete must apply. \r\n\r\nBy default, when a record is deleted, **Active-SQLAlchemy** actually sets ``is_deleted`` to True and excludes it from being queried, and ``deleted_at`` is also set. But this happens only when using the method ``db.Model.delete()``.\r\n\r\nWhen a record is soft-deleted, you can also undelete a record by doing: ``db.Model.delete(False)``\r\n\r\nNow, to totally delete off the table, ``db.Model.delete(hard_delete=True)``   \r\n\r\n\r\n**-- Querying with *db.Model.all()* --**\r\n\r\nDue to the fact that **Active-SQLAlchemy** has soft-delete, to query a model without the soft-deleted records, you must query your model by using the ``all(*args, **kwargs)`` which returns a db.session.query object for you to apply filter on etc.\r\n\r\n\r\n**-- db.BaseModel --**\r\n\r\nBy default ``db.Model`` adds several preset columns on the table, if you don't want to have them in your model, you can use instead ``db.BaseModel``, which still give you access to the methods to query your model.\r\n\r\n\r\n---\r\n\r\n\r\n### db.Model Methods Description\r\n\r\n**all(\\*args, \\*\\*kwargs)**\r\n\r\nReturns a ``db.session.query`` object to filter or apply more conditions. \r\n\r\n\tall = User.all()\r\n\tfor user in all:\r\n\t\tprint(user.login)\r\n\r\nBy default all() will show only all non-soft-delete records. To display both deleted and non deleted items, add the arg: ``exclude_deleted=False``\r\n\r\n\tall = User.all(exclude_deleted=False)\r\n\tfor user in all:\r\n\t\tprint(user.login)\r\n\t\t\r\nUse all to select columns etc\r\n\r\n\tall = User.all(User.name.distinct(), User.location)\r\n\tfor user in all:\r\n\t\tprint(user.login)\r\n\t\r\nUse all for complete filter\r\n\r\n\tall = User.all(User.name.distinct, User.location).order_by(User.updated_at.desc()).filter(User.location == \"Charlotte\")\r\n\t\t\r\n**get(id)**\r\n\r\nGet one record by id. By default it will query only a record that is not soft-deleted\r\n\r\n\tid = 1234\r\n\tuser = User.get(id)\r\n\r\n\tprint(user.id)\r\n\tprint(user.login)\r\n\r\nTo query a record that has been soft deleted, just set the argument ``exclude_deleted=False``\r\n\r\n\tid = 234\r\n\tuser = User.get(id, exclude_deleted=False)\r\n\t\t\r\n\t\t\r\n**create(\\*\\*kwargs)**\r\n\r\nTo create/insert new record. Same as __init__, but just a shortcut to it.\r\n\r\n\trecord = User.create(login='abc', passw_hash='hash', profile_id=123)\r\n\tprint (record.login) # -> abc\r\n\r\nor you can use the __init__ with save()\r\n\r\n\trecord = User(login='abc', passw_hash='hash', profile_id=123).save()\r\n\tprint (record.login) # -> abc\r\n\t\r\nor \r\n\r\n\trecord = User(login='abc', passw_hash='hash', profile_id=123)\r\n\trecord.save()\r\n\tprint (record.login) # -> abc\r\n\t\r\n\t\r\n**update(\\*\\*kwargs)**\r\n\r\nUpdate an existing record \r\n\r\n\trecord = User.get(124)\r\n\trecord.update(login='new_login')\r\n\tprint (record.login) # -> new_login\r\n\r\n**delete()**\r\n\r\nTo soft delete a record. ``is_deleted`` will be set to True and ``deleted_at`` datetime will be set\r\n\r\n\trecord = User.get(124)\r\n\trecord.delete()\r\n\tprint (record.is_deleted) # -> True\r\n\t\r\nTo soft UNdelete a record. ``is_deleted`` will be set to False and ``deleted_at`` datetime will be None\r\n\r\n\r\n\trecord = User.get(124)\r\n\trecord.delete(delete=False)\r\n\tprint (record.is_deleted) # -> False\r\n\t\r\nTo HARD delete a record. The record will be deleted completely\r\n\r\n\trecord = User.get(124)\r\n\trecord.delete(hard_delete=True)\r\n\r\n\r\n**save()**\r\n\r\nA shortcut to ``session.add`` + ``session.commit()``\r\n\r\n\trecord = User.get(124)\r\n\trecord.login = \"Another one\"\r\n\trecord.save()\r\n\r\n---\r\n\r\n#### Method Chaining \r\n\r\nFor convenience, some method chaining are available\r\n\r\n\tuser = User(name=\"Mardix\", location=\"Charlotte\").save()\r\n\t\r\n\tUser.get(12345).update(location=\"Atlanta\")\r\n\t\r\n\tUser.get(345).delete().delete(False).update(location=\"St. Louis\")\r\n\r\n---\r\n\r\n\r\n#### Aggegated selects\r\n\r\n\tclass Product(db.Model):\r\n    \tname = db.Column(db.String(250))\r\n    \tprice = db.Column(db.Numeric)\r\n    \t\r\n    results = Product.all(db.func.sum(Unit.price).label('price'))\r\n\r\n\r\n---\r\n\r\n## With Web Application\r\n\r\nIn a web application you need to call ``db.session.remove()`` after each response, and ``db.session.rollback()`` if an error occurs. However, if you are using Flask or other framework that uses the `after_request` and ``on_exception`` decorators, these bindings it is done automatically.\r\n\r\nFor example using Flask, you can do:\r\n\r\n\r\n    app = Flask(__name__)\r\n\r\n    db = SQLAlchemy('sqlite://', app=app)\r\n\r\nor\r\n\r\n    db = SQLAlchemy()\r\n\r\n    app = Flask(__name__)\r\n\r\n    db.init_app(app)\r\n\r\n\r\n### More examples\r\n\r\n####Many databases, one web app\r\n\r\n\r\n    app = Flask(__name__)\r\n    db1 = SQLAlchemy(URI1, app)\r\n    db2 = SQLAlchemy(URI2, app)\r\n\r\n\r\n####Many web apps, one database\r\n\r\n\r\n    db = SQLAlchemy(URI1)\r\n\r\n    app1 = Flask(__name__)\r\n    app2 = Flask(__name__)\r\n    db.init_app(app1)\r\n    db.init_app(app2)\r\n\r\n        \r\n---\r\n\r\n## Pagination\r\n\r\nAll the results can be easily paginated\r\n\r\n    users = User.paginate(page=2, per_page=20)\r\n    print(list(users))  # [User(21), User(22), User(23), ... , User(40)]\r\n\r\n\r\nThe paginator object it's an iterable that returns only the results for that page, so you use it in your templates in the same way than the original result:\r\n\r\n\r\n\r\n    {% for item in paginated_items %}\r\n        <li>{{ item.name }}</li>\r\n    {% endfor %}\r\n\r\n\r\nRendering the pages\r\n\r\nBelow your results is common that you want it to render the list of pages.\r\n\r\nThe ``paginator.pages`` property is an iterator that returns the page numbers, but sometimes not all of them: if there are more than 11 pages, the result will be one of these, depending of what is the current page:\r\n\r\n\r\nSkipped page numbers are represented as ``None``.\r\n\r\nHow many items are displayed can be controlled calling ``paginator.iter_pages`` instead.\r\n\r\nThis is one way how you could render such a pagination in your templates:\r\n\r\n\r\n\r\n    {% macro render_paginator(paginator, endpoint) %}\r\n      <p>Showing {{ paginator.showing }} or {{ paginator.total }}</p>\r\n\r\n      <ol class=\"paginator\">\r\n      {%- if paginator.has_prev %}\r\n        <li><a href=\"{{ url_for(endpoint, page=paginator.prev_num) }}\"\r\n         rel=\"me prev\">«</a></li>\r\n      {% else %}\r\n        <li class=\"disabled\"><span>«</span></li>\r\n      {%- endif %}\r\n\r\n      {%- for page in paginator.pages %}\r\n        {% if page %}\r\n          {% if page != paginator.page %}\r\n            <li><a href=\"{{ url_for(endpoint, page=page) }}\"\r\n             rel=\"me\">{{ page }}</a></li>\r\n          {% else %}\r\n            <li class=\"current\"><span>{{ page }}</span></li>\r\n          {% endif %}\r\n        {% else %}\r\n          <li><span class=ellipsis>…</span></li>\r\n        {% endif %}\r\n      {%- endfor %}\r\n\r\n      {%- if paginator.has_next %}\r\n        <li><a href=\"{{ url_for(endpoint, page=paginator.next_num) }}\"\r\n         rel=\"me next\">»</a></li>\r\n      {% else %}\r\n        <li class=\"disabled\"><span>»</span></li>\r\n      {%- endif %}\r\n      </ol>\r\n    {% endmacro %}\r\n\r\n______\r\n\r\n####Credits:\r\n\r\n[SQLAlchemy](http://www.sqlalchemy.org/)\r\n\r\n[Flask-SQLAlchemy](https://pythonhosted.org/Flask-SQLAlchemy)\r\n\r\n[SQLAlchemy-Wrapper](https://github.com/lucuma/sqlalchemy-wrapper)\r\n\r\n---\r\n\r\n:copyright: 2014\r\n\r\n:license: MIT, see LICENSE for more details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}